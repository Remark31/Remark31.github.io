<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="三尺微命，一介书生">
<meta property="og:type" content="website">
<meta property="og:title" content="Remark31">
<meta property="og:url" content="https://remark31.github.io/index.html">
<meta property="og:site_name" content="Remark31">
<meta property="og:description" content="三尺微命，一介书生">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Remark31">
<meta name="twitter:description" content="三尺微命，一介书生">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://remark31.github.io/"/>





  <title>Remark31</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Remark31</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://remark31.github.io/2018/05/26/POS初探/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Remark">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Remark31">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/26/POS初探/" itemprop="url">POS初探</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-26T23:47:43+08:00">
                2018-05-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文是阅读 <a href="https://github.com/ethereum/wiki/wiki/Proof-of-Stake-FAQ" target="_blank" rel="noopener">https://github.com/ethereum/wiki/wiki/Proof-of-Stake-FAQ</a> 以及 <a href="https://ethfans.org/posts/Proof-of-Stake-FAQ-new-2018-3-15" target="_blank" rel="noopener">https://ethfans.org/posts/Proof-of-Stake-FAQ-new-2018-3-15</a> 后自己总结的一些小点，更多的细节需要继续参照原文</p>
</blockquote>
<h2 id="什么是权益证明"><a href="#什么是权益证明" class="headerlink" title="什么是权益证明"></a>什么是权益证明</h2><blockquote>
<p>权益证明（PoS）是一类应用于公共区块链的共识算法，取决于验证者在网络中的经济权益。</p>
</blockquote>
<p>在基于权益证明的公共区块链（如以太坊即将实现的Casper协议）中，一组验证者轮流提议并票决下一个区块，而每位验证者的投票权重取决于其保证金额的大小（即权益）。权益证明的重要优势包括保障安全性、降低中心化危险以及提升能源效率。</p>
<p>一个通常的权益证明如下：</p>
<ul>
<li>区块链会追踪一个<strong>验证者集</strong></li>
<li>持有币的人可以通过一种发送一种<strong>将币锁定为保证金的特殊交易</strong>成为<strong>验证者</strong></li>
<li>创造并认可新区块的过程可通过当前所有验证者均可参与的共识算法来完成</li>
</ul>
<p>权益证明分类</p>
<ul>
<li>基于区块链的权益证明</li>
<li>拜占庭容错（BFT）型权益证明</li>
</ul>
<h3 id="基于区块链的权益证明"><a href="#基于区块链的权益证明" class="headerlink" title="基于区块链的权益证明"></a>基于区块链的权益证明</h3><ul>
<li>伪随机选择一个验证者</li>
<li>验证者出块</li>
<li>新创造的区块必须跟在之前的某个区块（通常是位于最长链的末端的区块）后面</li>
</ul>
<h3 id="拜占庭容错（BFT）型权益证明"><a href="#拜占庭容错（BFT）型权益证明" class="headerlink" title="拜占庭容错（BFT）型权益证明"></a>拜占庭容错（BFT）型权益证明</h3><ul>
<li>随机选择出块验证者</li>
<li>多轮过程投票</li>
<li>决定区块是否添加到链上</li>
</ul>
<h2 id="权益证明相对于工作量证明的优点"><a href="#权益证明相对于工作量证明的优点" class="headerlink" title="权益证明相对于工作量证明的优点"></a>权益证明相对于工作量证明的优点</h2><ul>
<li>不需要为了保护区块链而消耗大量电力</li>
<li>不需要为了保持参与者积极性发型很多新代币，可以烧掉</li>
<li>有助于抑制中心化卡特尔式机构的形成</li>
<li>降低中心化风险，不需要投资大量矿机</li>
<li>能够采用经济处罚，这让发动各种形式的51%攻击所要付出的代价比在工作量证明中高出许多</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">卡特尔(Cartel)是指生产同类商品的企业，为了获取高额利润，在划分市场、规定商品产量、确定商品价格等一个或几个方面达成协议而形成的垄断性联合。</span><br><span class="line"></span><br><span class="line">辛迪加(Syndicat)是同一生产部门的企业为了获取高额垄断利润，通过签订协议，共同采购原料和销售商品，而形成的垄断性联合。</span><br><span class="line"></span><br><span class="line">托拉斯(Trust)是垄断组织的一种高级形式，通常指生产同类商品或在生产上有密切联系的企业，为了获取高额利润，从生产到销售全面合并，而形成的垄断联合。</span><br><span class="line"></span><br><span class="line">康采恩(Konzem)是分属于不同部门的企业，以实力最为雄厚的企业为核心而结成的垄断联合，是一种高级而复杂的垄断组织。</span><br></pre></td></tr></table></figure>
<h2 id="权益证明将如何适应传统拜占庭容错研究"><a href="#权益证明将如何适应传统拜占庭容错研究" class="headerlink" title="权益证明将如何适应传统拜占庭容错研究"></a>权益证明将如何适应传统拜占庭容错研究</h2><ul>
<li><p>CAP定理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果网络出现分区，你必须在一致性和可用性中选择一个，不能二者兼得</span><br></pre></td></tr></table></figure>
</li>
<li><p>FLP不可能定理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在异步环境中（即使在正常运行的节点之间，也无法控制网络延时上限），不可能创造出一种算法，在出现单个故障或不诚实的节点之时，确保能在任何特定的有限时间内达成共识。</span><br></pre></td></tr></table></figure>
</li>
<li><p>容错范围</p>
<ul>
<li>在部分同步的网络模型（即网络延时虽有上限，却不知上限值）中运行的协议可以容忍超过1/3的任意错误</li>
<li>在异步模式（即对网络延时没有范围限制）下的决定性协议不能容忍错误（虽然文章中没有提及随机化算法的容错率高达1/3）</li>
<li>在同步模式（即网络延时保证会低于某个已知数）下的协议竟然能够实现100%的容错，不过在出错节点大于等于1/2时有一些限制条件。</li>
</ul>
</li>
</ul>
<h3 id="POW的容错"><a href="#POW的容错" class="headerlink" title="POW的容错"></a>POW的容错</h3><ul>
<li>与网络延迟有关系，不存在网络延迟的话容错率在50%</li>
<li>实际上以太坊容错率为46%，比特币是49.5%</li>
<li>网络延迟等于区块生成时间，容错率下降至33%</li>
</ul>
<h3 id="POS的容错"><a href="#POS的容错" class="headerlink" title="POS的容错"></a>POS的容错</h3><ul>
<li>同步网络模型：“基于区块链的”权益证明算法</li>
<li>部分异步网络模型：将部分同步网络中的传统拜占庭容错共识与权益证明联系起来</li>
</ul>
<h2 id="“无利害关系”问题是什么？如何解决？"><a href="#“无利害关系”问题是什么？如何解决？" class="headerlink" title="“无利害关系”问题是什么？如何解决？"></a>“无利害关系”问题是什么？如何解决？</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><blockquote>
<p>在许多早期（基于区块链的）权益证明算法（包括 Peercoin）中，只为创造区块提供奖励，且没有惩罚措施。这就造成了不幸的结果，在出现多条区块链相互竞争的情况下，会激励验证者在每条链上都创造区块，以确保获得奖励</p>
</blockquote>
<p>简单的说即是在POS算法中，参与者可以对于自己收到的链都进行下注，获得更多的期望收益，而在POW中，如果分开下注会导致算力下降，期望收益降低。</p>
<ul>
<li>POS的攻击者只需要比无私节点(只在正确链上下注)更多的算力，即可</li>
<li>POW的攻击者一定要比无私节点和理性节点都要多的算力，即可</li>
</ul>
<h3 id="解决策略"><a href="#解决策略" class="headerlink" title="解决策略"></a>解决策略</h3><h4 id="方案一：惩罚证明"><a href="#方案一：惩罚证明" class="headerlink" title="方案一：惩罚证明"></a>方案一：惩罚证明</h4><blockquote>
<p>惩罚证明：两个冲突的已签名区块头</p>
</blockquote>
<p>简单的说即是发现对多条链同时出块的验证着，会将惩罚证明纳入区块链，再扣除有恶意行为(同时向多条链出块)的验证者的保证金</p>
<h5 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h5><ul>
<li>提前很久确定验证集<ul>
<li>验证集不同会导致向两边同时出块 </li>
</ul>
</li>
<li>节点保持联网状态</li>
<li>存在中程验证者窜谋的风险<ul>
<li>连续30名验证者中有25人联合起来，提前同意在之前的19个区块上发动51%攻击</li>
</ul>
</li>
</ul>
<h4 id="方案二：惩罚在错误链上出块的证明者"><a href="#方案二：惩罚在错误链上出块的证明者" class="headerlink" title="方案二：惩罚在错误链上出块的证明者"></a>方案二：惩罚在错误链上出块的证明者</h4><p>简单的说即是对在错误链上出块的验证者进行罚金惩罚</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是一种和POW的惩罚很类似的做法，POW在错误链上出块的节点会浪费电费，POS就会直接损失权益，这会导致验证者的风险加大，但是好处在于不需要提前知道验证着是谁</span><br></pre></td></tr></table></figure>
<h2 id="拜占庭容错型权益证明算法目前是如何运作的？"><a href="#拜占庭容错型权益证明算法目前是如何运作的？" class="headerlink" title="拜占庭容错型权益证明算法目前是如何运作的？"></a>拜占庭容错型权益证明算法目前是如何运作的？</h2><p>允许验证者通过发送一种或者多种类型的签名信息对区块进行“投票”</p>
<h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ul>
<li>确定条件<ul>
<li>什么样的情况下一个特定的哈希可以被认为是确定值</li>
</ul>
</li>
<li>惩罚条件<ul>
<li>什么样的情况下一个特定的验证着可以被认定位恶意行为者</li>
</ul>
</li>
</ul>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><ul>
<li><p>如果 <code>MESSAGES</code> 包含 <code>[&quot;COMMIT&quot;, HASH1, view]</code> 和 <code>[&quot;COMMIT&quot;, HASH2, view]</code> 形式的信息，其中由同一个验证者签署的 <code>view</code> 是相同的，但 <code>HASH1</code> 和 <code>HASH2</code> 是不同的，那么该验证者就会受到惩罚。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">同时向两个块签名投票</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果<code>MESSAGES</code>包含 <code>[&quot;COMMIT&quot;, HASH, view1]</code> 形式的信息，那么除非<code>view1</code> = -1或是同时包含某个特定 <code>view2</code> 的 <code>[&quot;PREPARE&quot;, HASH, view1, view2]</code> 形式的信息，且 <code>view2</code> &lt; <code>view1</code> ，由 2/3 的验证者签署，那么下达COMMIT命令的验证者就会受到惩罚。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">只要有2/3以上的验证者就可以产生确定值，否则会受到惩罚</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>可问责安全性<ul>
<li>如果互相冲突的<code>HASH1</code> 和 <code>HASH2</code> （也就是说 <code>HASH1</code> 和 <code>HASH2</code> 是不同的，且互不为衍生值）是确定值，那么至少有1/3的验证者违反了某个惩罚条件。</li>
</ul>
</li>
<li>似乎合理的活性<ul>
<li>除非有1/3以上的验证者违反了惩罚条件，只要有2/3以上的验证者就可以产生确定值。</li>
</ul>
</li>
</ul>
<h2 id="“经济确定性”的一般概念是什么？"><a href="#“经济确定性”的一般概念是什么？" class="headerlink" title="“经济确定性”的一般概念是什么？"></a>“经济确定性”的一般概念是什么？</h2><blockquote>
<p>经济确定性的意思是一旦某个区块确定了下来，或者更普遍地说，一旦已经签署了足够的特定消息，在未来的任意时刻，想要让合法的历史记录包含冲突区块，只有在很多人愿意为此消耗大笔金钱的情况下才能实现。如果一个节点认为某个区块满足了该条件，就会有强大的经济保障来支持这个区块将成为所有人都认同的合法区块历史的一部分。</p>
</blockquote>
<h3 id="达到经济确定性的方式"><a href="#达到经济确定性的方式" class="headerlink" title="达到经济确定性的方式"></a>达到经济确定性的方式</h3><ul>
<li>如果足够数量的验证者已经签署了“我同意在所有不包含区块B的链中损失X”这种形式的加密经济声明，就可以从经济上确定一个区块。</li>
<li>如果足够数量的验证者已经签署了支持区块B的信息，就可以从经济上确定一个区块。</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>实现确定性方法源自于非利害关系问题的两个解决方案：</p>
<ul>
<li>惩罚<code>验证错误区块</code></li>
<li>惩罚<code>同时验证冲突区块</code></li>
</ul>
<h2 id="经济确定性与拜占庭容错理论的关联"><a href="#经济确定性与拜占庭容错理论的关联" class="headerlink" title="经济确定性与拜占庭容错理论的关联"></a>经济确定性与拜占庭容错理论的关联</h2><h3 id="传统的拜占庭容错理论"><a href="#传统的拜占庭容错理论" class="headerlink" title="传统的拜占庭容错理论"></a>传统的拜占庭容错理论</h3><ul>
<li>假设大体会具有相似的安全性（safety）和活跃度（liveness）特点</li>
<li>只需要在2/3的验证者是诚实的情况下就可以实现安全性</li>
<li>试图证明的是“如果机制M出现安全故障，会有至少1/3的节点出了错”</li>
</ul>
<h3 id="经济确定性模型理论"><a href="#经济确定性模型理论" class="headerlink" title="经济确定性模型理论"></a>经济确定性模型理论</h3><ul>
<li>证明的是“如果机制M出现安全故障，会有至少1/3的节点出了错，即使你在发生故障时离线了，也能知道是那些节点发生了故障”。</li>
<li>从活跃度角度来看，该模型更加容易，因为不需要证明网络将达成共识，只需要证明网络不会阻塞。</li>
<li>问责型（即如果你犯了可被抓住的那类错误，我们就可以为之制定惩罚条件）</li>
<li>会与延迟混淆型（要注意即使是信息发送过早这样的错误也会与延迟混淆，通过调快所有人的时间并让没有过早发送的信息出现更高的延迟可以模拟出这一情况）</li>
</ul>
<h3 id="弱主观性"><a href="#弱主观性" class="headerlink" title="弱主观性"></a>弱主观性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">此处需要再次调研</span><br></pre></td></tr></table></figure>
<h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><ul>
<li>假设保证金被锁定时间是4个月</li>
<li>6个月后发动了51%攻击，重新导入之前的区块</li>
<li>恶意验证着可以从主链上取回保证金，不受惩罚</li>
</ul>
<h4 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">区块回滚限制（revert limit）</span><br></pre></td></tr></table></figure>
<ul>
<li>节点必须拒绝回滚比保证金被锁定时间更久的区块（按照上例来说就是4个月）</li>
<li>节点可能会基于它们看到某些消息的时间而得出不同的结论(“主观的”)</li>
<li>进行链外验证</li>
</ul>
<h4 id="权益证明链不需要与工作量证明链“锚定”"><a href="#权益证明链不需要与工作量证明链“锚定”" class="headerlink" title="权益证明链不需要与工作量证明链“锚定”"></a>权益证明链不需要与工作量证明链“锚定”</h4><ul>
<li>锚定机制本身不安全</li>
<li>弱主观性只是一个安全性假设的一个很小的附加部分，不需要外部来源信任来支持</li>
</ul>
<h3 id="权益证明中的经济上惩罚审查制"><a href="#权益证明中的经济上惩罚审查制" class="headerlink" title="权益证明中的经济上惩罚审查制"></a>权益证明中的经济上惩罚审查制</h3><h4 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h4><p>区块链不能直接分辨出</p>
<ul>
<li>用户 A 尝试发送交易 X 但它被不公平地删掉了</li>
<li>用户 A 尝试发送交易 X，但因为交易费不够而始终没有被打包到区块中</li>
<li>用户 A 从未发送交易 X</li>
</ul>
<p>三者的不同</p>
<h4 id="可用技术"><a href="#可用技术" class="headerlink" title="可用技术"></a>可用技术</h4><ul>
<li>利用停机问题来抵御审查</li>
<li>交易通过时间锁加密<ul>
<li>验证者将在不知道交易内容的情况下打包交易，并且交易只有在（被打包）之后内容才会自动显示</li>
<li></li>
</ul>
</li>
<li>将审查识别包含在分叉选择规则中<ul>
<li>节点监视网络中的交易，如果他们观察到一笔交易在足够长的时间内包含足够高的费用，他们就会为不包含该交易的区块链打一个 “低分”。 </li>
<li>包含了该区块的少数链会自动合并，所有诚实在线节点都将在其后挖矿</li>
</ul>
</li>
</ul>
<h2 id="验证者选择机制的工作原理与“权益研磨-Grinding-”"><a href="#验证者选择机制的工作原理与“权益研磨-Grinding-”" class="headerlink" title="验证者选择机制的工作原理与“权益研磨(Grinding)”"></a>验证者选择机制的工作原理与“权益研磨(Grinding)”</h2><h3 id="权益研磨-Grinding"><a href="#权益研磨-Grinding" class="headerlink" title="权益研磨(Grinding)"></a>权益研磨(Grinding)</h3><blockquote>
<p>验证者通过执行一些计算或者采取某些其他措施使得随机性更偏向他们</p>
</blockquote>
<ul>
<li>在<code>Peercoin(点点币)</code>中，验证者可以“研磨”许多参数组合 ，并找到最有利的参数来增加它们的币产生合法区块的可能性。</li>
<li>在一个现已不存在的实现中，第N+1个区块的随机性取决于第N个区块的签名。这就允许验证者反复产生新签名，直到找到允许他们产生下一个区块的签名，从而永远掌握系统的控制权。</li>
<li>在 NXT 中，第 N+1个区块的随机性取决于产生第N个区块的验证者。这就允许验证者通过简单的跳过一次产生区块的机会来操纵随机性。这里的机会成本等于一个区块奖励，但是有时候新的随机数种子将在接下来的几十个区块中使得验证者获取多于平均值区块产生权的区块数。</li>
</ul>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul>
<li>要求验证者提前将他们的代币抵押</li>
<li>避免使用会被轻易操纵的数据信息作为随机性的源数据</li>
<li>使用基于秘密共享或确定性阈值签名的方案，并且让验证者合作产生随机数值<ul>
<li>33%-50% 的验证者勾结才可以干涉操作，导致协议必须假设有 67% 的活跃诚实节点）。    </li>
</ul>
</li>
<li><p>使用加密经济方案</p>
<ul>
<li>验证者提前提交信息(先发布sha3(x))</li>
<li>必须在区块中发布x</li>
<li>将x添加到随机数池中</li>
</ul>
</li>
<li><p>使用 Iddo Bentov的 “多数信号”</p>
<ul>
<li>使用其他信号产生的前 N 个随机数的 bit-majority （众数位）来生成一个随机数</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果大多数源数据的第一位是 1，那么结果的第一位是1，否则是0，如果大多数源数据的第二位是1，那么结果的第二位是1，否则是0，依此类推</span><br></pre></td></tr></table></figure>
<p>对于加密经济方案的攻击方式</p>
<ul>
<li>在提交阶段操纵 x <ul>
<li>不切实际</li>
</ul>
</li>
<li>选择性避免发布区块<ul>
<li>该攻击将消耗一个区块奖励的机会成本</li>
<li>明确的轮空罚款来进一步惩罚</li>
</ul>
</li>
</ul>
<h2 id="在-Casper-中的51-攻击"><a href="#在-Casper-中的51-攻击" class="headerlink" title="在 Casper 中的51% 攻击"></a>在 Casper 中的51% 攻击</h2><h3 id="确定性回滚"><a href="#确定性回滚" class="headerlink" title="确定性回滚"></a>确定性回滚</h3><blockquote>
<p>验证者已经确认区块 A 之后，又确认了另一竞争区块 A’；从而打破区块链的确定性保证</p>
</blockquote>
<ul>
<li>通过社区协调，使全社区专注于某一条分支挖矿</li>
</ul>
<h3 id="拒绝区块活性"><a href="#拒绝区块活性" class="headerlink" title="拒绝区块活性"></a>拒绝区块活性</h3><blockquote>
<p>一个算力大于等于34%的验证者联盟可以轻易拒绝添加更多的区块，而不必试图回滚区块</p>
</blockquote>
<ul>
<li>该协议可以包含一个自动轮换验证者集合的功能</li>
<li>规定在这种情况下，所有未参与共识过程的旧验证者，（系统）会对他们的存款收取大量的罚金。</li>
<li>使用硬分叉的方式添加新的验证者，并删除攻击者的余额。</li>
</ul>
<h3 id="屏蔽攻击"><a href="#屏蔽攻击" class="headerlink" title="屏蔽攻击"></a>屏蔽攻击</h3><blockquote>
<p>算力大于等于34%的验证者拒绝添加某个包含他们不喜欢的某些交易类型的区块，但区块链将继续运行，区块也会持续被添加到区块链中。这可能是一些温和的屏蔽攻击，只是用屏蔽的方法来干涉某些具体的应用</p>
</blockquote>
<ul>
<li>协议内添加功能使交易能够自动安排未来的事件</li>
<li>主动分叉选择规则<ul>
<li>通过尝试与给定的区块链交互或者验证其是否在审查你，来决定给定区块链是否是有效的</li>
<li>节点重复发送预定存储他们的以太币的交易，并在最后时刻取消该笔交易</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://remark31.github.io/2018/05/25/Solidity的学习之路/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Remark">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Remark31">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/25/Solidity的学习之路/" itemprop="url">Solidity的学习之路</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-25T19:39:37+08:00">
                2018-05-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="合约"><a href="#合约" class="headerlink" title="合约"></a>合约</h1><h2 id="基本结构与节本数据类型"><a href="#基本结构与节本数据类型" class="headerlink" title="基本结构与节本数据类型"></a>基本结构与节本数据类型</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul>
<li>全局变量<ul>
<li>会持久化到区块中</li>
</ul>
</li>
<li>局部变量<ul>
<li>仅仅在内存中执行</li>
</ul>
</li>
</ul>
<h3 id="时间变量"><a href="#时间变量" class="headerlink" title="时间变量"></a>时间变量</h3><ul>
<li>now</li>
<li>seconds</li>
<li>minutes</li>
<li>hours</li>
<li>days</li>
<li>weeks</li>
<li>years</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uint lastUpdated;</span><br><span class="line"></span><br><span class="line">// 将‘上次更新时间’ 设置为 ‘现在’</span><br><span class="line">function updateTimestamp() public &#123;</span><br><span class="line">  lastUpdated = now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果到上次`updateTimestamp` 超过5分钟，返回 &apos;true&apos;</span><br><span class="line">// 不到5分钟返回 &apos;false&apos;</span><br><span class="line">function fiveMinutesHavePassed() public view returns (bool) &#123;</span><br><span class="line">  return (now &gt;= (lastUpdated + 5 minutes));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><ul>
<li>用 keccak256 来制造随机数</li>
<li>其他参考资料：<a href="https://ethereum.stackexchange.com/questions/191/how-can-i-securely-generate-a-random-number-in-my-smart-contract" target="_blank" rel="noopener">https://ethereum.stackexchange.com/questions/191/how-can-i-securely-generate-a-random-number-in-my-smart-contract</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 生成一个0到100的随机数:</span><br><span class="line">uint randNonce = 0;</span><br><span class="line">uint random = uint(keccak256(now, msg.sender, randNonce)) % 100;</span><br><span class="line">randNonce++;</span><br><span class="line">uint random2 = uint(keccak256(now, msg.sender, randNonce)) % 100;</span><br></pre></td></tr></table></figure>
<h3 id="maps"><a href="#maps" class="headerlink" title="maps"></a>maps</h3><p>和普通代码编程的map并无区别，存储键值对</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapping (address =&gt; uint) public accountBalance;</span><br></pre></td></tr></table></figure>
<h3 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h3><ul>
<li>加法: <code>x + y</code></li>
<li>减法: <code>x - y</code></li>
<li>乘法: <code>x * y</code></li>
<li>除法: <code>x / y</code></li>
<li>取模: <code>x % y</code></li>
<li>乘方: <code>x ** y</code></li>
</ul>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul>
<li>公共数组：Solidity 会自动创建 getter 方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person[] public people;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul>
<li>keccak256：内部SHA3散列函数</li>
<li>uint8(a)</li>
</ul>
<h3 id="Storage与Memory"><a href="#Storage与Memory" class="headerlink" title="Storage与Memory"></a>Storage与Memory</h3><ul>
<li>Storage 永久存储在区块链中的变量    </li>
<li><p>Memory 存储在内存中的变量</p>
<ul>
<li>状态变量（在函数之外声明的变量）默认为“存储”形式，并永久写入区块链；</li>
<li>而在函数内部声明的变量是“内存”型的，它们函数调用结束后消失。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">contract SandwichFactory &#123;</span><br><span class="line">  struct Sandwich &#123;</span><br><span class="line">    string name;</span><br><span class="line">    string status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Sandwich[] sandwiches;</span><br><span class="line"></span><br><span class="line">  function eatSandwich(uint _index) public &#123;</span><br><span class="line">    // Sandwich mySandwich = sandwiches[_index];</span><br><span class="line"></span><br><span class="line">    // ^ 看上去很直接，不过 Solidity 将会给出警告</span><br><span class="line">    // 告诉你应该明确在这里定义 `storage` 或者 `memory`。</span><br><span class="line"></span><br><span class="line">    // 所以你应该明确定义 `storage`:</span><br><span class="line">    Sandwich storage mySandwich = sandwiches[_index];</span><br><span class="line">    // ...这样 `mySandwich` 是指向 `sandwiches[_index]`的指针</span><br><span class="line">    // 在存储里，另外...</span><br><span class="line">    mySandwich.status = &quot;Eaten!&quot;;</span><br><span class="line">    // ...这将永久把 `sandwiches[_index]` 变为区块链上的存储</span><br><span class="line"></span><br><span class="line">    // 如果你只想要一个副本，可以使用`memory`:</span><br><span class="line">    Sandwich memory anotherSandwich = sandwiches[_index + 1];</span><br><span class="line">    // ...这样 `anotherSandwich` 就仅仅是一个内存里的副本了</span><br><span class="line">    // 另外</span><br><span class="line">    anotherSandwich.status = &quot;Eaten!&quot;;</span><br><span class="line">    // ...将仅仅修改临时变量，对 `sandwiches[_index + 1]` 没有任何影响</span><br><span class="line">    // 不过你可以这样做:</span><br><span class="line">    sandwiches[_index + 1] = anotherSandwich;</span><br><span class="line">    // ...如果你想把副本的改动保存回区块链存储</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><ul>
<li>if </li>
<li>for </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function getEvens() pure external returns(uint[]) &#123;</span><br><span class="line">  uint[] memory evens = new uint[](5);</span><br><span class="line">  // 在新数组中记录序列号</span><br><span class="line">  uint counter = 0;</span><br><span class="line">  // 在循环从1迭代到10：</span><br><span class="line">  for (uint i = 1; i &lt;= 10; i++) &#123;</span><br><span class="line">    // 如果 `i` 是偶数...</span><br><span class="line">    if (i % 2 == 0) &#123;</span><br><span class="line">      // 把它加入偶数数组</span><br><span class="line">      evens[counter] = i;</span><br><span class="line">      //索引加一， 指向下一个空的‘even’</span><br><span class="line">      counter++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return evens;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li>私有:private</li>
<li>公共:public</li>
<li>返回值</li>
</ul>
<ul>
<li>内部：internal：<ul>
<li>internal 和 private 类似，不过， 如果某个合约继承自其父合约，这个合约即可以访问父合约中定义的“内部”函数。</li>
</ul>
</li>
<li>外部：external<ul>
<li>external与public 类似，只不过这些函数只能在合约之外调用。</li>
</ul>
</li>
</ul>
<ul>
<li>多返回值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function multipleReturns() internal returns(uint a, uint b, uint c) &#123;</span><br><span class="line">  return (1, 2, 3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function processMultipleReturns() external &#123;</span><br><span class="line">  uint a;</span><br><span class="line">  uint b;</span><br><span class="line">  uint c;</span><br><span class="line">  // 这样来做批量赋值:</span><br><span class="line">  (a, b, c) = multipleReturns();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 或者如果我们只想返回其中一个变量:</span><br><span class="line">function getLastReturnValue() external &#123;</span><br><span class="line">  uint c;</span><br><span class="line">  // 可以对其他字段留空:</span><br><span class="line">  (,,c) = multipleReturns();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>结构体传参</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function _doStuff(Zombie storage _zombie) internal &#123;</span><br><span class="line">  // do stuff with _zombie</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><ul>
<li>pure：不读取应用里的状态</li>
<li><p>view：只读取数据，不更改数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function _generateRandomDna(string _str) private view returns (uint) &#123;</span><br><span class="line">        uint rand = uint(keccak256(_str));</span><br><span class="line">        return rand % dnaModulus;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以带参数</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 存储用户年龄的映射</span><br><span class="line">mapping (uint =&gt; uint) public age;</span><br><span class="line"></span><br><span class="line">// 限定用户年龄的修饰符</span><br><span class="line">modifier olderThan(uint _age, uint _userId) &#123;</span><br><span class="line">  require(age[_userId] &gt;= _age);</span><br><span class="line">  _;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 必须年满16周岁才允许开车 (至少在美国是这样的).</span><br><span class="line">// 我们可以用如下参数调用`olderThan` 修饰符:</span><br><span class="line">function driveCar(uint _userId) public olderThan(16, _userId) &#123;</span><br><span class="line">  // 其余的程序逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>payable</li>
</ul>
<p>msg.value表示查看向合约中发送了多少以太的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">contract OnlineStore &#123;</span><br><span class="line">  function buySomething() external payable &#123;</span><br><span class="line">    // 检查以确定0.001以太发送出去来运行函数:</span><br><span class="line">    require(msg.value == 0.001 ether);</span><br><span class="line">    // 如果为真，一些用来向函数调用者发送数字内容的逻辑</span><br><span class="line">    transferThing(msg.sender);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>提现</li>
</ul>
<p>this.balance 存储了现有的eth<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">contract GetPaid is Ownable &#123;</span><br><span class="line">  function withdraw() external onlyOwner &#123;</span><br><span class="line">    owner.transfer(this.balance);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>TIPS.     </li>
<li><ol>
<li>不能有相同名称的修饰符和函数。</li>
</ol>
</li>
</ul>
<h2 id="包的导入"><a href="#包的导入" class="headerlink" title="包的导入"></a>包的导入</h2><ul>
<li>引入文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &quot;./someothercontract.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract newContract is SomeOtherContract &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>与普通的结构体并无区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct Person &#123;</span><br><span class="line">    uint age;</span><br><span class="line">    string name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接口与事件"><a href="#接口与事件" class="headerlink" title="接口与事件"></a>接口与事件</h2><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><ul>
<li>事件 是合约和区块链通讯的一种机制。你的前端应用“监听”某些事件，并做出反应。</li>
</ul>
<ul>
<li><p>事件创建</p>
</li>
<li><p>事件通知</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory &#123;</span><br><span class="line"></span><br><span class="line">    event NewZombie(uint zombieId, string name, uint dna);</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie &#123;</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    function _createZombie(string _name, uint _dna) private &#123;</span><br><span class="line">        uint id = zombies.push(Zombie(_name, _dna)) - 1;</span><br><span class="line">        NewZombie(id, _name, _dna);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _generateRandomDna(string _str) private view returns (uint) &#123;</span><br><span class="line">        uint rand = uint(keccak256(_str));</span><br><span class="line">        return rand % dnaModulus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function createRandomZombie(string _name) public &#123;</span><br><span class="line">        uint randDna = _generateRandomDna(_name);</span><br><span class="line">        _createZombie(_name, randDna);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul>
<li>定义接口</li>
</ul>
<ul>
<li>使用接口</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">假设原合约为：</span><br><span class="line">contract LuckyNumber &#123;</span><br><span class="line">  mapping(address =&gt; uint) numbers;</span><br><span class="line"></span><br><span class="line">  function setNum(uint _num) public &#123;</span><br><span class="line">    numbers[msg.sender] = _num;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getNum(address _myAddress) public view returns (uint) &#123;</span><br><span class="line">    return numbers[_myAddress];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在新合约中定义接口为：</span><br><span class="line">contract NumberInterface &#123;</span><br><span class="line">  function getNum(address _myAddress) public view returns (uint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在新合约中使用接口为：</span><br><span class="line">contract MyContract &#123;</span><br><span class="line">  address NumberInterfaceAddress = 0xab38...;</span><br><span class="line">  // ^ 这是FavoriteNumber合约在以太坊上的地址</span><br><span class="line">  NumberInterface numberContract = NumberInterface(NumberInterfaceAddress);</span><br><span class="line">  // 现在变量 `numberContract` 指向另一个合约对象</span><br><span class="line"></span><br><span class="line">  function someFunction() public &#123;</span><br><span class="line">    // 现在我们可以调用在那个合约中声明的 `getNum`函数:</span><br><span class="line">    uint num = numberContract.getNum(msg.sender);</span><br><span class="line">    // ...在这儿使用 `num`变量做些什么</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="合约交互"><a href="#合约交互" class="headerlink" title="合约交互"></a>合约交互</h2><h3 id="msg-sender"><a href="#msg-sender" class="headerlink" title="msg.sender"></a>msg.sender</h3><ul>
<li>指的是当前调用者（或智能合约）的 address。</li>
</ul>
<h3 id="Require"><a href="#Require" class="headerlink" title="Require"></a>Require</h3><ul>
<li>使得函数在执行过程中，当不满足某些条件时抛出错误，并停止执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(keccak256(_name) == keccak256(&quot;Vitalik&quot;));</span><br></pre></td></tr></table></figure>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h3><ul>
<li>与普通面向对象语言的继承一样</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ontract Doge &#123;</span><br><span class="line">  function catchphrase() public returns (string) &#123;</span><br><span class="line">    return &quot;So Wow CryptoDoge&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract BabyDoge is Doge &#123;</span><br><span class="line">  function anotherCatchphrase() public returns (string) &#123;</span><br><span class="line">    return &quot;Such Moon BabyDoge&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><ul>
<li>使用多重继承的时候，你只需要用逗号 , 来隔开几个你想要继承的合约</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract SatoshiNakamoto is NickSzabo, HalFinney &#123;</span><br><span class="line">  // 啧啧啧，宇宙的奥秘泄露了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="合约库"><a href="#合约库" class="headerlink" title="合约库"></a>合约库</h2><h3 id="Ownable-合约"><a href="#Ownable-合约" class="headerlink" title="Ownable 合约"></a>Ownable 合约</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @title Ownable</span><br><span class="line"> * @dev The Ownable contract has an owner address, and provides basic authorization control</span><br><span class="line"> * functions, this simplifies the implementation of &quot;user permissions&quot;.</span><br><span class="line"> */</span><br><span class="line">contract Ownable &#123;</span><br><span class="line">  address public owner;</span><br><span class="line">  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev The Ownable constructor sets the original `owner` of the contract to the sender</span><br><span class="line">   * account.</span><br><span class="line">   */</span><br><span class="line">  function Ownable() public &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev Throws if called by any account other than the owner.</span><br><span class="line">   */</span><br><span class="line">  modifier onlyOwner() &#123;</span><br><span class="line">    require(msg.sender == owner);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev Allows the current owner to transfer control of the contract to a newOwner.</span><br><span class="line">   * @param newOwner The address to transfer ownership to.</span><br><span class="line">   */</span><br><span class="line">  function transferOwnership(address newOwner) public onlyOwner &#123;</span><br><span class="line">    require(newOwner != address(0));</span><br><span class="line">    OwnershipTransferred(owner, newOwner);</span><br><span class="line">    owner = newOwner;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>构造函数：function Ownable()，初始化函数</li>
<li>函数修饰符：modifier onlyOwner()，用来修饰其它已有函数<ul>
<li>执行时先执行修饰符中的内容，到<code>_</code>部分后开始执行原有函数的内容</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">contract MyContract is Ownable &#123;</span><br><span class="line">  event LaughManiacally(string laughter);</span><br><span class="line"></span><br><span class="line">  //注意！ `onlyOwner`上场 :</span><br><span class="line">  function likeABoss() external onlyOwner &#123;</span><br><span class="line">    LaughManiacally(&quot;Muahahahaha&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ERC721-标准"><a href="#ERC721-标准" class="headerlink" title="ERC721 标准"></a>ERC721 标准</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">contract ERC721 &#123;</span><br><span class="line">  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);</span><br><span class="line">  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _owner) public view returns (uint256 _balance);</span><br><span class="line">  function ownerOf(uint256 _tokenId) public view returns (address _owner);</span><br><span class="line">  function transfer(address _to, uint256 _tokenId) public;  // 转移想移到的地址和代币</span><br><span class="line">  function approve(address _to, uint256 _tokenId) public;   // 存储谁被允许提取代币</span><br><span class="line">  function takeOwnership(uint256 _tokenId) public;          // 调用此处时检查后转移代币</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="safeMath"><a href="#safeMath" class="headerlink" title="safeMath"></a>safeMath</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">library SafeMath &#123;</span><br><span class="line"></span><br><span class="line">  function mul(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    if (a == 0) &#123;</span><br><span class="line">      return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    uint256 c = a * b;</span><br><span class="line">    assert(c / a == b);</span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function div(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    // assert(b &gt; 0); // Solidity automatically throws when dividing by 0</span><br><span class="line">    uint256 c = a / b;</span><br><span class="line">    // assert(a == b * c + a % b); // There is no case in which this doesn&apos;t hold</span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function sub(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    assert(b &lt;= a);</span><br><span class="line">    return a - b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function add(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    uint256 c = a + b;</span><br><span class="line">    assert(c &gt;= a);</span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">using SafeMath for uint256;</span><br><span class="line"></span><br><span class="line">uint256 a = 5;</span><br><span class="line">uint256 b = a.add(3); // 5 + 3 = 8</span><br><span class="line">uint256 c = a.mul(2); // 5 * 2 = 10</span><br></pre></td></tr></table></figure>
<h2 id="Gas的节省套路"><a href="#Gas的节省套路" class="headerlink" title="Gas的节省套路"></a>Gas的节省套路</h2><ul>
<li>如果一个 struct 中有多个 uint，则尽可能使用较小的 uint, Solidity 会将这些 uint 打包在一起，从而占用较少的存储空间</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct NormalStruct &#123;</span><br><span class="line">  uint a;</span><br><span class="line">  uint b;</span><br><span class="line">  uint c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct MiniMe &#123;</span><br><span class="line">  uint32 a;</span><br><span class="line">  uint32 b;</span><br><span class="line">  uint c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>view 函数不花费gas</li>
<li>使用内存数组解决gas</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://remark31.github.io/2018/05/25/初识比特币/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Remark">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Remark31">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/25/初识比特币/" itemprop="url">初识比特币</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-25T19:39:37+08:00">
                2018-05-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="关于比特币"><a href="#关于比特币" class="headerlink" title="关于比特币"></a>关于比特币</h1><p>比特币作为一个2009年诞生的点对点的支付系统，在几乎无人运维的情况下运转到了如今，很多人为之赋予了各种意义。现在我们尝试着剥离资本的面纱，看看这个元祖虚拟币是怎么工作的。</p>
<h2 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1.数据结构"></a>1.数据结构</h2><p>在这里，我们尝试从两方面来了解比特币，区块链以及UTXO(Unspent Transaction Output，未花费的交易输出)</p>
<h3 id="1-1-区块链"><a href="#1-1-区块链" class="headerlink" title="1.1 区块链"></a>1.1 区块链</h3><p>在比特币中，存储数据的数据结构是区块链，顾名思义就是区块形成的链，区块中的数据结构大致如下图所示    </p>
<table>
<thead>
<tr>
<th>数据名称</th>
<th style="text-align:left">数据说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Time</td>
<td style="text-align:left">当前区块生成的时间</td>
</tr>
<tr>
<td>Nonce</td>
<td style="text-align:left">随机数，用于工作量证明</td>
</tr>
<tr>
<td>PrevousHash</td>
<td style="text-align:left">前一个区块的哈希</td>
</tr>
<tr>
<td>&lt; transactions &gt;</td>
<td style="text-align:left">区块中包含的交易列表</td>
</tr>
</tbody>
</table>
<p>通过PrevousHash，每一个区块都和上一个区块关联起来，随着时间的流逝就创建出了一个持续增长的去快来了，它不断地更新，从而能够代表比特币账本的最新状态。</p>
<h3 id="1-2-UTXO"><a href="#1-2-UTXO" class="headerlink" title="1.2 UTXO"></a>1.2 UTXO</h3><p>比特币系统中没有账号，只有UTXO。每个UTXO都有一个面值和所有者(这就是大家喜闻乐见的地址)。</p>
<p>每一笔交易包含一个或多个输入和一个或多个输出。每个输出包含一个新的加入到状态中的UTXO。    </p>
<p>这样讲可能难以理解，简单的说可以把UTXO理解成交易流水。在比特币系统中没有用户，只有每个地址相关的流水，当某个地址需要交易时就开始从当前地址相关的UTXO的输出中开始凑，直到输入凑够了需要交易的数量，如果有多，没关系，从输出中找零。当某一笔流水已经被用过了，就从自己的账户中划掉。    </p>
<p>举个例子：小张的户头上有4笔UTXO，输出分别为2块，3块，5块，10块。现在小张想向小李转16块钱，于是小张就开始凑输入，发现需要3+5+10=18就能超过16块钱。于是小张发起了交易，一个新的UTXO被生成，这个输入分别是3块，5块和10块，输出是小张的地址2块，小李的地址16块。同时小张地址上本身的3块，5块，10块的UTXO被消耗掉了。</p>
<h2 id="2-工作量证明与挖矿"><a href="#2-工作量证明与挖矿" class="headerlink" title="2.工作量证明与挖矿"></a>2.工作量证明与挖矿</h2><p>在上文的数据结构中提到了Nonce，这实际上是一个“无用”的随机数。这个随机数是由SHA-256计算的。这个随机数的特点就是非常难以计算，但是很容易验算。要算出这个随机数，只能通过反复的尝试，简单的说就是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(i := 0 ; i &lt; MAX ; i ++)&#123;</span><br><span class="line">    if check(i) &#123;</span><br><span class="line">        return i</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        continue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>能算出来这个Nonce，就能代表该节点完成了工作量的证明。这个工作量证明解决了“谁是大多数的问题”，“大多数”的决定表达为最长的链，因为最长的链包含了最大的工作量。如果大多数的CPU为诚实的节点控制，那么诚实的链条将以最快的速度延长，并超越其他的竞争链条。</p>
<p>想要攻击这个系统的人就需要拥有更强的算力，如果这是一个为了利益的攻击者的话，他会发现用这个算力在系统中合法经营会获得更高的收益，攻击这个系统会使这个系统贬值。</p>
<p>在同一时间有大量的节点进行这个Nonce的计算，但是最快的节点的计算会被认可。其它节点的算力会被浪费掉了。整体这些计算和打包交易的行为可以认为是“挖矿”。比特币为了奖励矿工的计算，会凭空发给矿工一笔25BTC(这个数字在逐渐的减少)的交易。</p>
<p>可以看到，比特币的工作量证明实际上是一个很低效和浪费很大的事情，极大的算力浪费在了计算Nonce，但这确实是一个很简洁很民主的事情，通过难以伪造的算力的投票确定了谁才是大多数，保证整个系统是符合大多数人的利益的。</p>
<h2 id="3-交易策略"><a href="#3-交易策略" class="headerlink" title="3.交易策略"></a>3.交易策略</h2><blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">快速交易、赌徒破产问题/其他的攻击</span><br></pre></td></tr></table></figure>
<p>现实社会中的交易是很明确的一手交钱一手交货，钱已经到手了就不太会被转走了。而在比特币上是如何的呢？    </p>
<p>比特币仍然是一手交钱一手交货，问题在于交钱之后钱不一定到手上，或者会出现一种“看上去到手”的错觉。比特币大约是10分钟生成一个新块，那么在交易完成后我们需要大致等待10分钟，期待交易会被打包在最新的块上。当我们看到了交易之后，交易真的完成了吗？并非那么确定。</p>
<p>在上一节我们可以看到比特币系统会信任最长的链，有些脸黑的情况下我们的交易并没有被打包到最长的链上，而是某些次长的链上，所以我们还需要更多时间去确认，节点投赞成票的方式就是在认可的链条后挖矿，因此当打包我们交易的块后产生了足够多的块，那么我们就可以认为这个交易已经被真真正正的写成功了，就可以愉快的银货两讫了。</p>
<p>从这点可以看到，比特币要用于线下即时交易是有一些困难的，这个确认时间确实有点长，而且还是在基本无人作恶的情况下。那么当有算力攻击时会怎么样呢？</p>
<p>这里中本聪给出了数学证明，将这个问题近似的看成了<code>赌徒破产问题</code>，得出了计算结论：如果攻击者的算力比诚实矿工的算力低，那么攻击成功的概率会因为区块数的增长而呈指数化的下降。</p>
<h2 id="4-一些瞎侃"><a href="#4-一些瞎侃" class="headerlink" title="4.一些瞎侃"></a>4.一些瞎侃</h2><h3 id="匿名"><a href="#匿名" class="headerlink" title="匿名"></a>匿名</h3><p>在比特币网络上的交易都是一串地址与另一串地址，只是在网络上流转时，是无人知道这个地址后面的是猫还是狗。然而由于比特币的价值波动，更多是一种投资品，最终人们还是需要提现法币，在提现的时候，这个匿名就被打破了。因为人们需要和现实世界产生关系，银行、交易所或者其它的一些结构能够通过对地址账户上的提交的监控确定到账户和个人的关联，从而顺藤摸瓜拉出一大片。这样想一想，其实现金交易的匿名性会更好，当然，现金没有U盘好携带。</p>
<h3 id="特色主义算力攻击"><a href="#特色主义算力攻击" class="headerlink" title="特色主义算力攻击"></a>特色主义算力攻击</h3><p>比特币之前的主要算力是在国内，由于众所周知的原因，国内连接国外的网络其实一般，如果在某一天与国外节点发生了断网，那么比特币上的交易就会被分成两个链，大家各自产生了自己的链和交易。当某一天网络恢复，那么这两个链就会被合二为一，由算力开始投票，某一条链上的交易都会被抛弃，如果真的到了那样一天，比特币会如何发展？ 这真是一件很有趣的事情。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Remark</p>
              <p class="site-description motion-element" itemprop="description">三尺微命，一介书生</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Remark</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
