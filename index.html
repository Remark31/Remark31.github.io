<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Remark31</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="it&apos;s a Remark31&apos;s blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Remark31">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Remark31">
<meta property="og:description" content="it&apos;s a Remark31&apos;s blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Remark31">
<meta name="twitter:description" content="it&apos;s a Remark31&apos;s blog">
  
    <link rel="alternate" href="/atom.xml" title="Remark31" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Remark31</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-初识比特币" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/25/初识比特币/" class="article-date">
  <time datetime="2018-05-25T11:39:37.000Z" itemprop="datePublished">2018-05-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/25/初识比特币/">初识比特币</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <h1 id="关于比特币"><a href="#关于比特币" class="headerlink" title="关于比特币"></a>关于比特币</h1><p>比特币作为一个2009年诞生的点对点的支付系统，在几乎无人运维的情况下运转到了如今，很多人为之赋予了各种意义。现在我们尝试着剥离资本的面纱，看看这个元祖虚拟币是怎么工作的。</p>
<h2 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1.数据结构"></a>1.数据结构</h2><p>在这里，我们尝试从两方面来了解比特币，区块链以及UTXO(Unspent Transaction Output，未花费的交易输出)</p>
<h3 id="1-1-区块链"><a href="#1-1-区块链" class="headerlink" title="1.1 区块链"></a>1.1 区块链</h3><p>在比特币中，存储数据的数据结构是区块链，顾名思义就是区块形成的链，区块中的数据结构大致如下图所示<br>| 数据名称 | 数据说明 |<br>| :——–|:———|<br>| Time   | 当前区块生成的时间|<br>| Nonce    | 随机数，用于工作量证明|<br>| PrevousHash | 前一个区块的哈希|<br>| <transactions>| 区块中包含的交易列表|</transactions></p>
<p>通过PrevousHash，每一个区块都和上一个区块关联起来，随着时间的流逝就创建出了一个持续增长的去快来了，它不断地更新，从而能够代表比特币账本的最新状态。</p>
<h3 id="1-2-UTXO"><a href="#1-2-UTXO" class="headerlink" title="1.2 UTXO"></a>1.2 UTXO</h3><p>比特币系统中没有账号，只有UTXO。每个UTXO都有一个面值和所有者(这就是大家喜闻乐见的地址)。</p>
<p>每一笔交易包含一个或多个输入和一个或多个输出。每个输出包含一个新的加入到状态中的UTXO。    </p>
<p>这样讲可能难以理解，简单的说可以把UTXO理解成交易流水。在比特币系统中没有用户，只有每个地址相关的流水，当某个地址需要交易时就开始从当前地址相关的UTXO的输出中开始凑，直到输入凑够了需要交易的数量，如果有多，没关系，从输出中找零。当某一笔流水已经被用过了，就从自己的账户中划掉。    </p>
<p>举个例子：小张的户头上有4笔UTXO，输出分别为2块，3块，5块，10块。现在小张想向小李转16块钱，于是小张就开始凑输入，发现需要3+5+10=18就能超过16块钱。于是小张发起了交易，一个新的UTXO被生成，这个输入分别是3块，5块和10块，输出是小张的地址2块，小李的地址16块。同时小张地址上本身的3块，5块，10块的UTXO被消耗掉了。</p>
<h2 id="2-工作量证明与挖矿"><a href="#2-工作量证明与挖矿" class="headerlink" title="2.工作量证明与挖矿"></a>2.工作量证明与挖矿</h2><p>在上文的数据结构中提到了Nonce，这实际上是一个“无用”的随机数。这个随机数是由SHA-256计算的。这个随机数的特点就是非常难以计算，但是很容易验算。要算出这个随机数，只能通过反复的尝试，简单的说就是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(i := 0 ; i &lt; MAX ; i ++)&#123;</span><br><span class="line">    if check(i) &#123;</span><br><span class="line">        return i</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        continue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>能算出来这个Nonce，就能代表该节点完成了工作量的证明。这个工作量证明解决了“谁是大多数的问题”，“大多数”的决定表达为最长的链，因为最长的链包含了最大的工作量。如果大多数的CPU为诚实的节点控制，那么诚实的链条将以最快的速度延长，并超越其他的竞争链条。</p>
<p>想要攻击这个系统的人就需要拥有更强的算力，如果这是一个为了利益的攻击者的话，他会发现用这个算力在系统中合法经营会获得更高的收益，攻击这个系统会使这个系统贬值。</p>
<p>在同一时间有大量的节点进行这个Nonce的计算，但是最快的节点的计算会被认可。其它节点的算力会被浪费掉了。整体这些计算和打包交易的行为可以认为是“挖矿”。比特币为了奖励矿工的计算，会凭空发给矿工一笔25BTC(这个数字在逐渐的减少)的交易。</p>
<p>可以看到，比特币的工作量证明实际上是一个很低效和浪费很大的事情，极大的算力浪费在了计算Nonce，但这确实是一个很简洁很民主的事情，通过难以伪造的算力的投票确定了谁才是大多数，保证整个系统是符合大多数人的利益的。</p>
<h2 id="3-交易策略"><a href="#3-交易策略" class="headerlink" title="3.交易策略"></a>3.交易策略</h2><blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">快速交易、赌徒破产问题/其他的攻击</span><br></pre></td></tr></table></figure>
<p>现实社会中的交易是很明确的一手交钱一手交货，钱已经到手了就不太会被转走了。而在比特币上是如何的呢？    </p>
<p>比特币仍然是一手交钱一手交货，问题在于交钱之后钱不一定到手上，或者会出现一种“看上去到手”的错觉。比特币大约是10分钟生成一个新块，那么在交易完成后我们需要大致等待10分钟，期待交易会被打包在最新的块上。当我们看到了交易之后，交易真的完成了吗？并非那么确定。</p>
<p>在上一节我们可以看到比特币系统会信任最长的链，有些脸黑的情况下我们的交易并没有被打包到最长的链上，而是某些次长的链上，所以我们还需要更多时间去确认，节点投赞成票的方式就是在认可的链条后挖矿，因此当打包我们交易的块后产生了足够多的块，那么我们就可以认为这个交易已经被真真正正的写成功了，就可以愉快的银货两讫了。</p>
<p>从这点可以看到，比特币要用于线下即时交易是有一些困难的，这个确认时间确实有点长，而且还是在基本无人作恶的情况下。那么当有算力攻击时会怎么样呢？</p>
<p>这里中本聪给出了数学证明，将这个问题近似的看成了<code>赌徒破产问题</code>，得出了计算结论：如果攻击者的算力比诚实矿工的算力低，那么攻击成功的概率会因为区块数的增长而呈指数化的下降。</p>
<h2 id="4-一些瞎侃"><a href="#4-一些瞎侃" class="headerlink" title="4.一些瞎侃"></a>4.一些瞎侃</h2><h3 id="匿名"><a href="#匿名" class="headerlink" title="匿名"></a>匿名</h3><p>在比特币网络上的交易都是一串地址与另一串地址，只是在网络上流转时，是无人知道这个地址后面的是猫还是狗。然而由于比特币的价值波动，更多是一种投资品，最终人们还是需要提现法币，在提现的时候，这个匿名就被打破了。因为人们需要和现实世界产生关系，银行、交易所或者其它的一些结构能够通过对地址账户上的提交的监控确定到账户和个人的关联，从而顺藤摸瓜拉出一大片。这样想一想，其实现金交易的匿名性会更好，当然，现金没有U盘好携带。</p>
<h3 id="特色主义算力攻击"><a href="#特色主义算力攻击" class="headerlink" title="特色主义算力攻击"></a>特色主义算力攻击</h3><p>比特币之前的主要算力是在国内，由于众所周知的原因，国内连接国外的网络其实一般，如果在某一天与国外节点发生了断网，那么比特币上的交易就会被分成两个链，大家各自产生了自己的链和交易。当某一天网络恢复，那么这两个链就会被合二为一，由算力开始投票，某一条链上的交易都会被抛弃，如果真的到了那样一天，比特币会如何发展？ 这真是一件很有趣的事情。</p>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/25/初识比特币/" data-id="cjhm16pea0000eajeja9yrsks" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/区块链/">区块链</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/杂谈/">杂谈</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/概念/">概念</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Solidity的学习之路" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/25/Solidity的学习之路/" class="article-date">
  <time datetime="2018-05-25T11:39:37.000Z" itemprop="datePublished">2018-05-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/25/Solidity的学习之路/">Solidity的学习之路</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <h1 id="合约"><a href="#合约" class="headerlink" title="合约"></a>合约</h1><h2 id="基本结构与节本数据类型"><a href="#基本结构与节本数据类型" class="headerlink" title="基本结构与节本数据类型"></a>基本结构与节本数据类型</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul>
<li>全局变量<ul>
<li>会持久化到区块中</li>
</ul>
</li>
<li>局部变量<ul>
<li>仅仅在内存中执行</li>
</ul>
</li>
</ul>
<h3 id="时间变量"><a href="#时间变量" class="headerlink" title="时间变量"></a>时间变量</h3><ul>
<li>now</li>
<li>seconds</li>
<li>minutes</li>
<li>hours</li>
<li>days</li>
<li>weeks</li>
<li>years</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uint lastUpdated;</span><br><span class="line"></span><br><span class="line">// 将‘上次更新时间’ 设置为 ‘现在’</span><br><span class="line">function updateTimestamp() public &#123;</span><br><span class="line">  lastUpdated = now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果到上次`updateTimestamp` 超过5分钟，返回 &apos;true&apos;</span><br><span class="line">// 不到5分钟返回 &apos;false&apos;</span><br><span class="line">function fiveMinutesHavePassed() public view returns (bool) &#123;</span><br><span class="line">  return (now &gt;= (lastUpdated + 5 minutes));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><ul>
<li>用 keccak256 来制造随机数</li>
<li>其他参考资料：<a href="https://ethereum.stackexchange.com/questions/191/how-can-i-securely-generate-a-random-number-in-my-smart-contract" target="_blank" rel="noopener">https://ethereum.stackexchange.com/questions/191/how-can-i-securely-generate-a-random-number-in-my-smart-contract</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 生成一个0到100的随机数:</span><br><span class="line">uint randNonce = 0;</span><br><span class="line">uint random = uint(keccak256(now, msg.sender, randNonce)) % 100;</span><br><span class="line">randNonce++;</span><br><span class="line">uint random2 = uint(keccak256(now, msg.sender, randNonce)) % 100;</span><br></pre></td></tr></table></figure>
<h3 id="maps"><a href="#maps" class="headerlink" title="maps"></a>maps</h3><p>和普通代码编程的map并无区别，存储键值对</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapping (address =&gt; uint) public accountBalance;</span><br></pre></td></tr></table></figure>
<h3 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h3><ul>
<li>加法: <code>x + y</code></li>
<li>减法: <code>x - y</code></li>
<li>乘法: <code>x * y</code></li>
<li>除法: <code>x / y</code></li>
<li>取模: <code>x % y</code></li>
<li>乘方: <code>x ** y</code></li>
</ul>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul>
<li>公共数组：Solidity 会自动创建 getter 方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person[] public people;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul>
<li>keccak256：内部SHA3散列函数</li>
<li>uint8(a)</li>
</ul>
<h3 id="Storage与Memory"><a href="#Storage与Memory" class="headerlink" title="Storage与Memory"></a>Storage与Memory</h3><ul>
<li>Storage 永久存储在区块链中的变量    </li>
<li><p>Memory 存储在内存中的变量</p>
<ul>
<li>状态变量（在函数之外声明的变量）默认为“存储”形式，并永久写入区块链；</li>
<li>而在函数内部声明的变量是“内存”型的，它们函数调用结束后消失。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">contract SandwichFactory &#123;</span><br><span class="line">  struct Sandwich &#123;</span><br><span class="line">    string name;</span><br><span class="line">    string status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Sandwich[] sandwiches;</span><br><span class="line"></span><br><span class="line">  function eatSandwich(uint _index) public &#123;</span><br><span class="line">    // Sandwich mySandwich = sandwiches[_index];</span><br><span class="line"></span><br><span class="line">    // ^ 看上去很直接，不过 Solidity 将会给出警告</span><br><span class="line">    // 告诉你应该明确在这里定义 `storage` 或者 `memory`。</span><br><span class="line"></span><br><span class="line">    // 所以你应该明确定义 `storage`:</span><br><span class="line">    Sandwich storage mySandwich = sandwiches[_index];</span><br><span class="line">    // ...这样 `mySandwich` 是指向 `sandwiches[_index]`的指针</span><br><span class="line">    // 在存储里，另外...</span><br><span class="line">    mySandwich.status = &quot;Eaten!&quot;;</span><br><span class="line">    // ...这将永久把 `sandwiches[_index]` 变为区块链上的存储</span><br><span class="line"></span><br><span class="line">    // 如果你只想要一个副本，可以使用`memory`:</span><br><span class="line">    Sandwich memory anotherSandwich = sandwiches[_index + 1];</span><br><span class="line">    // ...这样 `anotherSandwich` 就仅仅是一个内存里的副本了</span><br><span class="line">    // 另外</span><br><span class="line">    anotherSandwich.status = &quot;Eaten!&quot;;</span><br><span class="line">    // ...将仅仅修改临时变量，对 `sandwiches[_index + 1]` 没有任何影响</span><br><span class="line">    // 不过你可以这样做:</span><br><span class="line">    sandwiches[_index + 1] = anotherSandwich;</span><br><span class="line">    // ...如果你想把副本的改动保存回区块链存储</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><ul>
<li>if </li>
<li>for </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function getEvens() pure external returns(uint[]) &#123;</span><br><span class="line">  uint[] memory evens = new uint[](5);</span><br><span class="line">  // 在新数组中记录序列号</span><br><span class="line">  uint counter = 0;</span><br><span class="line">  // 在循环从1迭代到10：</span><br><span class="line">  for (uint i = 1; i &lt;= 10; i++) &#123;</span><br><span class="line">    // 如果 `i` 是偶数...</span><br><span class="line">    if (i % 2 == 0) &#123;</span><br><span class="line">      // 把它加入偶数数组</span><br><span class="line">      evens[counter] = i;</span><br><span class="line">      //索引加一， 指向下一个空的‘even’</span><br><span class="line">      counter++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return evens;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li>私有:private</li>
<li>公共:public</li>
<li>返回值</li>
</ul>
<ul>
<li>内部：internal：<ul>
<li>internal 和 private 类似，不过， 如果某个合约继承自其父合约，这个合约即可以访问父合约中定义的“内部”函数。</li>
</ul>
</li>
<li>外部：external<ul>
<li>external与public 类似，只不过这些函数只能在合约之外调用。</li>
</ul>
</li>
</ul>
<ul>
<li>多返回值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function multipleReturns() internal returns(uint a, uint b, uint c) &#123;</span><br><span class="line">  return (1, 2, 3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function processMultipleReturns() external &#123;</span><br><span class="line">  uint a;</span><br><span class="line">  uint b;</span><br><span class="line">  uint c;</span><br><span class="line">  // 这样来做批量赋值:</span><br><span class="line">  (a, b, c) = multipleReturns();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 或者如果我们只想返回其中一个变量:</span><br><span class="line">function getLastReturnValue() external &#123;</span><br><span class="line">  uint c;</span><br><span class="line">  // 可以对其他字段留空:</span><br><span class="line">  (,,c) = multipleReturns();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>结构体传参</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function _doStuff(Zombie storage _zombie) internal &#123;</span><br><span class="line">  // do stuff with _zombie</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><ul>
<li>pure：不读取应用里的状态</li>
<li><p>view：只读取数据，不更改数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function _generateRandomDna(string _str) private view returns (uint) &#123;</span><br><span class="line">        uint rand = uint(keccak256(_str));</span><br><span class="line">        return rand % dnaModulus;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以带参数</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 存储用户年龄的映射</span><br><span class="line">mapping (uint =&gt; uint) public age;</span><br><span class="line"></span><br><span class="line">// 限定用户年龄的修饰符</span><br><span class="line">modifier olderThan(uint _age, uint _userId) &#123;</span><br><span class="line">  require(age[_userId] &gt;= _age);</span><br><span class="line">  _;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 必须年满16周岁才允许开车 (至少在美国是这样的).</span><br><span class="line">// 我们可以用如下参数调用`olderThan` 修饰符:</span><br><span class="line">function driveCar(uint _userId) public olderThan(16, _userId) &#123;</span><br><span class="line">  // 其余的程序逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>payable</li>
</ul>
<p>msg.value表示查看向合约中发送了多少以太的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">contract OnlineStore &#123;</span><br><span class="line">  function buySomething() external payable &#123;</span><br><span class="line">    // 检查以确定0.001以太发送出去来运行函数:</span><br><span class="line">    require(msg.value == 0.001 ether);</span><br><span class="line">    // 如果为真，一些用来向函数调用者发送数字内容的逻辑</span><br><span class="line">    transferThing(msg.sender);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>提现</li>
</ul>
<p>this.balance 存储了现有的eth<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">contract GetPaid is Ownable &#123;</span><br><span class="line">  function withdraw() external onlyOwner &#123;</span><br><span class="line">    owner.transfer(this.balance);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>TIPS.     </li>
<li><ol>
<li>不能有相同名称的修饰符和函数。</li>
</ol>
</li>
</ul>
<h2 id="包的导入"><a href="#包的导入" class="headerlink" title="包的导入"></a>包的导入</h2><ul>
<li>引入文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &quot;./someothercontract.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract newContract is SomeOtherContract &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>与普通的结构体并无区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct Person &#123;</span><br><span class="line">    uint age;</span><br><span class="line">    string name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接口与事件"><a href="#接口与事件" class="headerlink" title="接口与事件"></a>接口与事件</h2><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><ul>
<li>事件 是合约和区块链通讯的一种机制。你的前端应用“监听”某些事件，并做出反应。</li>
</ul>
<ul>
<li><p>事件创建</p>
</li>
<li><p>事件通知</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory &#123;</span><br><span class="line"></span><br><span class="line">    event NewZombie(uint zombieId, string name, uint dna);</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie &#123;</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    function _createZombie(string _name, uint _dna) private &#123;</span><br><span class="line">        uint id = zombies.push(Zombie(_name, _dna)) - 1;</span><br><span class="line">        NewZombie(id, _name, _dna);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _generateRandomDna(string _str) private view returns (uint) &#123;</span><br><span class="line">        uint rand = uint(keccak256(_str));</span><br><span class="line">        return rand % dnaModulus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function createRandomZombie(string _name) public &#123;</span><br><span class="line">        uint randDna = _generateRandomDna(_name);</span><br><span class="line">        _createZombie(_name, randDna);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul>
<li>定义接口</li>
</ul>
<ul>
<li>使用接口</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">假设原合约为：</span><br><span class="line">contract LuckyNumber &#123;</span><br><span class="line">  mapping(address =&gt; uint) numbers;</span><br><span class="line"></span><br><span class="line">  function setNum(uint _num) public &#123;</span><br><span class="line">    numbers[msg.sender] = _num;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getNum(address _myAddress) public view returns (uint) &#123;</span><br><span class="line">    return numbers[_myAddress];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在新合约中定义接口为：</span><br><span class="line">contract NumberInterface &#123;</span><br><span class="line">  function getNum(address _myAddress) public view returns (uint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在新合约中使用接口为：</span><br><span class="line">contract MyContract &#123;</span><br><span class="line">  address NumberInterfaceAddress = 0xab38...;</span><br><span class="line">  // ^ 这是FavoriteNumber合约在以太坊上的地址</span><br><span class="line">  NumberInterface numberContract = NumberInterface(NumberInterfaceAddress);</span><br><span class="line">  // 现在变量 `numberContract` 指向另一个合约对象</span><br><span class="line"></span><br><span class="line">  function someFunction() public &#123;</span><br><span class="line">    // 现在我们可以调用在那个合约中声明的 `getNum`函数:</span><br><span class="line">    uint num = numberContract.getNum(msg.sender);</span><br><span class="line">    // ...在这儿使用 `num`变量做些什么</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="合约交互"><a href="#合约交互" class="headerlink" title="合约交互"></a>合约交互</h2><h3 id="msg-sender"><a href="#msg-sender" class="headerlink" title="msg.sender"></a>msg.sender</h3><ul>
<li>指的是当前调用者（或智能合约）的 address。</li>
</ul>
<h3 id="Require"><a href="#Require" class="headerlink" title="Require"></a>Require</h3><ul>
<li>使得函数在执行过程中，当不满足某些条件时抛出错误，并停止执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(keccak256(_name) == keccak256(&quot;Vitalik&quot;));</span><br></pre></td></tr></table></figure>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h3><ul>
<li>与普通面向对象语言的继承一样</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ontract Doge &#123;</span><br><span class="line">  function catchphrase() public returns (string) &#123;</span><br><span class="line">    return &quot;So Wow CryptoDoge&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract BabyDoge is Doge &#123;</span><br><span class="line">  function anotherCatchphrase() public returns (string) &#123;</span><br><span class="line">    return &quot;Such Moon BabyDoge&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><ul>
<li>使用多重继承的时候，你只需要用逗号 , 来隔开几个你想要继承的合约</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract SatoshiNakamoto is NickSzabo, HalFinney &#123;</span><br><span class="line">  // 啧啧啧，宇宙的奥秘泄露了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="合约库"><a href="#合约库" class="headerlink" title="合约库"></a>合约库</h2><h3 id="Ownable-合约"><a href="#Ownable-合约" class="headerlink" title="Ownable 合约"></a>Ownable 合约</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @title Ownable</span><br><span class="line"> * @dev The Ownable contract has an owner address, and provides basic authorization control</span><br><span class="line"> * functions, this simplifies the implementation of &quot;user permissions&quot;.</span><br><span class="line"> */</span><br><span class="line">contract Ownable &#123;</span><br><span class="line">  address public owner;</span><br><span class="line">  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev The Ownable constructor sets the original `owner` of the contract to the sender</span><br><span class="line">   * account.</span><br><span class="line">   */</span><br><span class="line">  function Ownable() public &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev Throws if called by any account other than the owner.</span><br><span class="line">   */</span><br><span class="line">  modifier onlyOwner() &#123;</span><br><span class="line">    require(msg.sender == owner);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev Allows the current owner to transfer control of the contract to a newOwner.</span><br><span class="line">   * @param newOwner The address to transfer ownership to.</span><br><span class="line">   */</span><br><span class="line">  function transferOwnership(address newOwner) public onlyOwner &#123;</span><br><span class="line">    require(newOwner != address(0));</span><br><span class="line">    OwnershipTransferred(owner, newOwner);</span><br><span class="line">    owner = newOwner;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>构造函数：function Ownable()，初始化函数</li>
<li>函数修饰符：modifier onlyOwner()，用来修饰其它已有函数<ul>
<li>执行时先执行修饰符中的内容，到<code>_</code>部分后开始执行原有函数的内容</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">contract MyContract is Ownable &#123;</span><br><span class="line">  event LaughManiacally(string laughter);</span><br><span class="line"></span><br><span class="line">  //注意！ `onlyOwner`上场 :</span><br><span class="line">  function likeABoss() external onlyOwner &#123;</span><br><span class="line">    LaughManiacally(&quot;Muahahahaha&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ERC721-标准"><a href="#ERC721-标准" class="headerlink" title="ERC721 标准"></a>ERC721 标准</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">contract ERC721 &#123;</span><br><span class="line">  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);</span><br><span class="line">  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _owner) public view returns (uint256 _balance);</span><br><span class="line">  function ownerOf(uint256 _tokenId) public view returns (address _owner);</span><br><span class="line">  function transfer(address _to, uint256 _tokenId) public;  // 转移想移到的地址和代币</span><br><span class="line">  function approve(address _to, uint256 _tokenId) public;   // 存储谁被允许提取代币</span><br><span class="line">  function takeOwnership(uint256 _tokenId) public;          // 调用此处时检查后转移代币</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="safeMath"><a href="#safeMath" class="headerlink" title="safeMath"></a>safeMath</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">library SafeMath &#123;</span><br><span class="line"></span><br><span class="line">  function mul(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    if (a == 0) &#123;</span><br><span class="line">      return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    uint256 c = a * b;</span><br><span class="line">    assert(c / a == b);</span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function div(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    // assert(b &gt; 0); // Solidity automatically throws when dividing by 0</span><br><span class="line">    uint256 c = a / b;</span><br><span class="line">    // assert(a == b * c + a % b); // There is no case in which this doesn&apos;t hold</span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function sub(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    assert(b &lt;= a);</span><br><span class="line">    return a - b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function add(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    uint256 c = a + b;</span><br><span class="line">    assert(c &gt;= a);</span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">using SafeMath for uint256;</span><br><span class="line"></span><br><span class="line">uint256 a = 5;</span><br><span class="line">uint256 b = a.add(3); // 5 + 3 = 8</span><br><span class="line">uint256 c = a.mul(2); // 5 * 2 = 10</span><br></pre></td></tr></table></figure>
<h2 id="Gas的节省套路"><a href="#Gas的节省套路" class="headerlink" title="Gas的节省套路"></a>Gas的节省套路</h2><ul>
<li>如果一个 struct 中有多个 uint，则尽可能使用较小的 uint, Solidity 会将这些 uint 打包在一起，从而占用较少的存储空间</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct NormalStruct &#123;</span><br><span class="line">  uint a;</span><br><span class="line">  uint b;</span><br><span class="line">  uint c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct MiniMe &#123;</span><br><span class="line">  uint32 a;</span><br><span class="line">  uint32 b;</span><br><span class="line">  uint c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>view 函数不花费gas</li>
<li>使用内存数组解决gas</li>
</ul>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/25/Solidity的学习之路/" data-id="cjhm16pej0001eajetd9483zy" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/以太坊/">以太坊</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/区块链/">区块链</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/智能合约/">智能合约</a></li></ul>

    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/以太坊/">以太坊</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/区块链/">区块链</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/智能合约/">智能合约</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/杂谈/">杂谈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/概念/">概念</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/以太坊/" style="font-size: 10px;">以太坊</a> <a href="/tags/区块链/" style="font-size: 20px;">区块链</a> <a href="/tags/智能合约/" style="font-size: 10px;">智能合约</a> <a href="/tags/杂谈/" style="font-size: 10px;">杂谈</a> <a href="/tags/概念/" style="font-size: 10px;">概念</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/05/25/初识比特币/">初识比特币</a>
          </li>
        
          <li>
            <a href="/2018/05/25/Solidity的学习之路/">Solidity的学习之路</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Remark<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>